section .data

    message1:  db "Введите a или b",0xa,0  ;сообщение вопроса, адрес начала строки
    ln1 equ $-message1                              ;длина сообщения
                                                    ;0xa - перенос строки
                                                    ;0 - не обязателен, но иногда может понадобиться, например при работе с C

    message2: db "Вы ввели a!",0xa,0               ;сообщение ответа, адрес начала строки
    ln2 equ $-message2                          ;длина сообщения

    message3:  db "Вы ввели b!",0xa,0               ;сообщение ответа, адрес начала строки
    ln3 equ $-message3                          ;длина сообщения

    enter: resb 1                                ;выделение памяти в 1 байт переменной enter
    lne equ $-enter                            ;длина сообщения


;начало самой программы
section .text
    global _start
    _start:
again:
;действия для вывода содержимого по умолчанию с началом в ecx, с длиной edx - вывод вопроса
mov ecx, message1       ;в ecx помещается адрес первого символа переменной
mov edx, ln1            ;в edx помещается количество символов в переменной
mov eax,4       ;эта строка №1 обязательна для вывода!
mov ebx,1       ;эта строка №2 обязательна для вывода!
int 0x80        ;эта строка №3 обязательна для вывода!

;действия для ввода содержимого по умолчанию с началом в ecx, с длиной edx - ввод ответа
mov eax, 3         ;эта строка №1 обязательна для ввода!
mov ebx, 0         ;эта строка №2 обязательна для ввода!

mov ecx, enter   ;в ecx помещается адрес первого символа из enter
mov edx, lne       ;в edx помещается количество символов в переменной, остальные заполнятся нулями

int 0x80           ;эта строка №3 обязательна для ввода!

;действия для сравнения содержимого
 cmp byte [ecx], 'a';при вводе данных через клавиатуру в ecx помещается адрес первого символа из всех существующих
                        ;поэтому при выводе надо указывать ecx в квадратных скобках, так как это адрес символа  [ecx]
                        ;и обязательно указывать размер, в данном случае byte, так как изначально резервировался размер в байтах resb


    je m1                 ;если введено a
    jne m2                 ;если введено не a

m1:                      ;переходит сюда, если введено a

    mov ecx,message2
    mov edx,ln2
    jmp exit              ;переход к метке exit


m2:                    ;переходит сюда, если введено не a
cmp byte [ecx], 'b'    ;при вводе данных через клавиатуру в ecx помещается адрес первого символа из всех существующих
je m3                  ;если введено b
jne again                 ;переход к метке again, если введено не b

m3:
    mov ecx,message3
    mov edx,ln3
    ;jmp exit              ;переход к метке exit, (тут в принципе прыгать не надо)



exit:
;вывод содержимого ecx
mov eax,4       ;эта строка №1 обязательна для вывода!
mov ebx,1       ;эта строка №2 обязательна для вывода!
int 0x80        ;эта строка №3 обязательна для вывода!

mov ax,1             ;выход
    int 0x80
